1. Structure of our program:
Our program functionality is mainly carried out by the main() function, with a couple helper functions that makes the main function more readable and simpler. 

Our main function can be divided into 5 parts, from top to bottom. The first part is the reaping for all background jobs, using the waitpid() function. We put the reap at the top because this is the time just before the next command prompt is shown within the while loop, so that all background jobs are properly checked and corresponding messages are printed before the next command. The second part is parsing, which is the same as that of Shell 1. The third part is handling the built-in commands, including exit, cd, ln, rm, jobs, bg, and fg. In particular, bg resumes a job in background, while fg resumes a job in foreground. fg is more complicated because it involves taking the terminal control and handing it back when the job terminates, so there is another waitpid() in the fg implementation. Last, we determine if the job (command) is a background job or not, and add that job to the job_list if it is. The fourth part is the child process. The first thing we did in the child process is to set the process's group id to its own pid no matter it is a foreground or a background job, so that each child process will have its unique pgid. This makes sure that a signal is sent only to a certain child process without affecting the parent process. Now, if the job is foreground, we give the terminal control to it. Same as Shell 1, we then handle redirections for file descriptors. Finally, we use the execv() command to deal with other built-in commands. The last part of the main() function is the reaping for a foreground job. This is again implemented with the waitpid() function. We put the reapping for the foreground job here because the shell has to wait for it to exit/be terminated by signal/be suspended by signal since it is running in the foreground. Finally, our shell takes the terminal control back and gets ready to receive the next command. Outside of the while loop, we clean the job list and return from the main() function. The cleaning function is also called wherever the shell is about to exit. 

2. Known bugs: N/A.

3. Distribution of work:
Together for functionality. Zixuan Guo responsible for annotation, Xilin Wang
responsible for readme. 
